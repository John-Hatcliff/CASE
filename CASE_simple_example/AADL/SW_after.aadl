package SW_after
public
	with Base_Types;
	with Data_Model;
	
	

	
	data color
		properties
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("Red", "Green", "Blue");
	end color;
	
	data coord
	end coord;
	data implementation coord.impl
		subcomponents
			lat: data Base_Types::Integer;
			lon: data Base_Types::Integer;
			alt: data Base_Types::Integer;
	end coord.impl;
	
	
	data wp_message
	end wp_message;
	data implementation wp_message.impl
		subcomponents
			clr: data color;
			crd: data coord.impl;
			xyz: data Base_Types::Integer;
	end wp_message.impl;
	
	
	thread RadioDriver
		features
			recv_map_in: in data port;
			send_status_out: out data port;
			send_status_in: in data port;
			recv_map_out: out data port wp_message.impl;
	end RadioDriver;
	
	thread Filter
		features
			xyz_map_in: in data port wp_message.impl;
			xyz_map_out: out data port wp_message.impl;
			annex agree {**
				--match val=recv_map.alt regexp=[0-9]+	
				--assert "filter assertion" : recv_map_out.coord.alt >= 50 and recv_map_out.color = enum (color, Red);
			**};
	end Filter; 
	
	thread implementation Filter.impl
		annex agree {**
			--match val=recv_map.alt regexp=[0-9]+	
			--assert "filter assertion" : recv_map_out.coord.alt >= 50 and recv_map_out.color = enum (color, Red);
		**};
	end Filter.impl;
	
	thread FlightPlanner
		features
			recv_map: in data port wp_message.impl;
			flight_plan: out data port;
			position_status: in data port;
			
						
		annex agree {**
				property adsf = recv_map.crd.alt >= 50 and (recv_map.clr = enum(color, Red) or recv_map.clr = enum (color, Green));
			assume "recv_map valid 1" : recv_map.crd.alt >= 50 and (recv_map.clr = enum (color, Red) or recv_map.clr = enum (color, Green));
		**};
	end FlightPlanner;


	thread WaypointManager
		features
			flight_plan: in data port;
			waypoint: out data port;
			position_status: in data port;

	end WaypointManager;
	
	thread UARTDriver
		features
			position_status_in: in data port;
			waypoint_out: out data port;
			position_status_out: out data port;
			waypoint_in: in data port;
	end UARTDriver;

	process MC_SW
		features
			recv_map: in data port;
			send_status: out data port;
			waypoint: out data port;
			position_status: in data port;
			
		annex agree{**
		**};
	end MC_SW;

	
	process implementation MC_SW.impl
		subcomponents
			RADIO: thread RadioDriver;
			FLTR: thread Filter;
			FPLN: thread FlightPlanner;
			WPM: thread WaypointManager;
			UART: thread UARTDriver;
		connections
			c1: port recv_map -> RADIO.recv_map_in;
			c2: port RADIO.send_status_out -> send_status;
			c3A: port RADIO.recv_map_out ->FLTR.xyz_map_in; 
			c3B: port FLTR.xyz_map_out -> FPLN.recv_map;
			c4: port FPLN.flight_plan -> WPM.flight_plan;
			c5: port WPM.waypoint -> UART.waypoint_in;
			c6: port UART.position_status_out -> WPM.position_status;
			c7: port UART.position_status_out -> FPLN.position_status;
			c8: port UART.position_status_out -> RADIO.send_status_in;
			c9: port UART.waypoint_out -> waypoint;
			c10: port position_status -> UART.position_status_in;
			
		annex agree{**
			assert "something's wrong'" : FPLN.recv_map > 0;
			--assign ghi = FLTR.xyz_map_out;
			--assert "filter assertion" : FLTR.recv_map_out.coord.alt >= 50 and FLTR.recv_map_out.color = enum (color, Red);
		**};

	end MC_SW.impl;	
	
	
end SW_after;